{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Solidity Security Demonstrations","text":"<p>A curated collection of Foundry-based tests demonstrating common security risks and user-operation vulnerabilities in Solidity smart contracts.</p> <p>The primary goal is educational: to illustrate real-world attack vectors, their exploitation mechanisms, and effective mitigations through clear, executable examples.</p>"},{"location":"#usage","title":"Usage","text":"<p>Run all tests:</p> <pre><code>forge test\n</code></pre> <p>Run a specific test with verbose output:</p> <pre><code>forge test --match-path test/ApproveScam.t.sol -vv\n</code></pre>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This repository contains proof-of-concept code that intentionally demonstrates insecure patterns and exploitation techniques in smart contracts.</p> <p>The content is strictly for educational and research purposes only. It must not be used for any illegal activities, unauthorized access, or exploitation of production systems.</p> <p>Users bear full responsibility for any actions taken based on this material. All usage must comply with applicable laws, regulations, and ethical standards.</p>"},{"location":"ApproveScam/","title":"Over-Permissive Approval Risk in ERC20 Tokens","text":""},{"location":"ApproveScam/#overview","title":"Overview","text":"<p>The ERC20 <code>approve</code> function allows a token owner to grant a spender permission to transfer a specified amount of tokens on their behalf via <code>transferFrom</code>. A common user mistake is approving an excessively large allowance\u2014often <code>type(uint256).max</code> (unlimited)\u2014to an untrusted or malicious address.</p> <p>Once granted, this allowance persists indefinitely until explicitly revoked or reduced. A malicious spender can then call <code>transferFrom</code> at any time to drain the owner's entire balance (up to the approved amount).</p> <p>This is not a vulnerability in the ERC20 standard itself but a user-operation risk exploited in many phishing scams and malicious dApps.</p>"},{"location":"ApproveScam/#demonstration","title":"Demonstration","text":"<p>The following Foundry test illustrates the risk:</p> <ul> <li>Alice receives 1000 TEST tokens.</li> <li>Alice approves Eve for an unlimited allowance.</li> <li>Eve immediately transfers all of Alice's tokens to herself.</li> </ul>"},{"location":"ApproveScam/#mitigation","title":"Mitigation","text":"<ul> <li>Approve only the exact amount required for the intended transaction.</li> <li>Use <code>increaseAllowance</code>/<code>decreaseAllowance</code> for incremental adjustments.</li> <li>Prefer tokens supporting EIP-2612 <code>permit</code> for off-chain signed approvals (no initial <code>approve</code> transaction needed).</li> <li>Regularly check and revoke unnecessary approvals using tools like Revoke.cash or Etherscan's Token Approval checker.</li> </ul>"},{"location":"ApproveScam/#running-the-test","title":"Running the Test","text":"<pre><code>forge test --match-contract ApproveScamTest -vv\n</code></pre> <p>The <code>-vv</code> flag displays console.log output, showing Eve's balance change from 0 to 1000 tokens after the exploit.</p>"},{"location":"ApproveScam/#expected-output","title":"Expected Output","text":"<pre><code>[PASS] test_overPermissiveApprovalExploit() (gas: 75653)\nLogs:\n  Eve balance before exploit: 0\n  Eve balance after exploit : 1000000000000000000000\n  Exploit completed: Alice's funds fully transferred to Eve\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 3.95ms\n</code></pre> <p>The logs confirm Eve's balance increases from 0 to 1,000 tokens (10\u00b9\u2078 wei units) after the exploit.</p>"},{"location":"ArrayDeletion/","title":"Improper Array Element Deletion Vulnerability","text":""},{"location":"ArrayDeletion/#overview","title":"Overview","text":"<p>Dynamic arrays in Solidity support the <code>delete</code> keyword to remove elements, but using <code>delete array[index]</code> does not reduce the array's length. Instead, it zeroes out the element at the specified index, leaving a gap in the array. This creates data inconsistencies and can lead to logic errors in contracts that iterate over arrays or assume contiguous data.</p> <p>The array retains its original length, and subsequent iterations will encounter zero values where elements were \"deleted.\" This is a common pitfall in dynamic array management that can cause unexpected behavior in production contracts.</p> <p>This is not a compiler bug but a language design choice\u2014developers must explicitly manage array length when removing elements.</p>"},{"location":"ArrayDeletion/#demonstration","title":"Demonstration","text":"<p>The following Foundry test illustrates the vulnerability:</p> <ul> <li>An array <code>[1, 2, 3, 4, 5]</code> is initialized with length 5.</li> <li>The vulnerable contract uses <code>delete items[1]</code> to remove the element at index 1.</li> <li>The array becomes <code>[1, 0, 3, 4, 5]</code> with length still 5 (zero-value gap created).</li> <li>The secure contract uses swap-and-pop to properly remove the element.</li> <li>The array becomes <code>[1, 5, 3, 4]</code> with length reduced to 4 (no gaps).</li> </ul>"},{"location":"ArrayDeletion/#mitigation","title":"Mitigation","text":""},{"location":"ArrayDeletion/#recommended-swap-and-pop-pattern-o1","title":"Recommended: Swap-and-Pop Pattern (O(1))","text":"<p>Replace the target element with the last element, then pop:</p> <pre><code>function removeElement(uint256 index) external {\n    require(index &lt; items.length, \"Index out of bounds\");\n    items[index] = items[items.length - 1];\n    items.pop();\n}\n</code></pre> <p>Trade-off: Does not preserve array order. Suitable when element order is irrelevant.</p>"},{"location":"ArrayDeletion/#alternative-shift-left-pattern-on","title":"Alternative: Shift-Left Pattern (O(n))","text":"<p>Shift all elements after the target index left by one position, then pop:</p> <pre><code>function removeElement(uint256 index) external {\n    require(index &lt; items.length, \"Index out of bounds\");\n    for (uint256 i = index; i &lt; items.length - 1; i++) {\n        items[i] = items[i + 1];\n    }\n    items.pop();\n}\n</code></pre> <p>Trade-off: Preserves array order but costs significantly more gas for large arrays.</p>"},{"location":"ArrayDeletion/#best-practices","title":"Best Practices","text":"<ul> <li>Never use <code>delete array[index]</code> unless you explicitly want to zero an element while maintaining length.</li> <li>Choose swap-and-pop for gas efficiency when order doesn't matter.</li> <li>Use shift-left only when order preservation is critical and array size is small.</li> <li>Consider using mapping-based structures if frequent deletions are required.</li> </ul>"},{"location":"ArrayDeletion/#running-the-test","title":"Running the Test","text":"<pre><code>forge test --match-contract ArrayDeletionTest -vv\n</code></pre> <p>The <code>-vv</code> flag displays console.log output, showing the array length and element values before and after deletion.</p>"},{"location":"ArrayDeletion/#expected-output","title":"Expected Output","text":"<pre><code>[PASS] test_SecureArrayDeletion() (gas: 29046)\nLogs:\n  Initial length: 5\n  Element at index 1: 2\n  Final length: 4\n  Element at index 1: 5\n\n[PASS] test_VulnerableArrayDeletion() (gas: 20588)\nLogs:\n  Initial length: 5\n  Element at index 1: 2\n  Final length: 5\n  Element at index 1: 0\n\nSuite result: ok. 2 passed; 0 failed; 0 skipped; finished in 512.41\u00b5s (268.97\u00b5s CPU time)\n</code></pre> <p>The logs confirm:</p> <ul> <li>Vulnerable pattern: Length remains 5, element becomes 0 (gap created).</li> <li>Secure pattern: Length reduces to 4, element becomes 5 (last element swapped in, no gap).</li> </ul>"},{"location":"ArrayDeletion/#real-world-impact","title":"Real-World Impact","text":"<p>This vulnerability has appeared in multiple audit reports:</p> <ul> <li>Gas inefficiency: Iterating over arrays with gaps wastes gas on zero-value checks.</li> <li>Logic errors: Contracts assuming contiguous data may skip valid elements or process zeros incorrectly.</li> <li>State corruption: Off-chain indexers and frontends may display incorrect data if they don't account for gaps.</li> </ul> <p>Always validate array deletion logic during security audits and ensure proper length management.</p>"},{"location":"BackdoorAssembly/","title":"Hidden Assembly Backdoor Vulnerability","text":""},{"location":"BackdoorAssembly/#overview","title":"Overview","text":"<p>Inline assembly in Solidity provides low-level access to the EVM, enabling direct manipulation of storage slots via <code>sload</code> and <code>sstore</code> operations. While assembly is necessary for certain optimizations, it can be weaponized to create hidden backdoors that bypass Solidity's type safety and access control mechanisms.</p> <p>A malicious contract deployer can use assembly to:</p> <ul> <li>Read and write arbitrary storage slots without triggering state variable checks</li> <li>Bypass modifier-based access controls by obscuring privilege verification logic</li> <li>Manipulate critical state variables (balances, ownership, permissions) invisibly</li> </ul> <p>This pattern has been observed in rug-pull scams where contracts appear legitimate but contain hidden administrative privileges.</p> <p>Unlike vulnerabilities in contract logic, assembly backdoors are intentional malicious design\u2014they represent a trust violation rather than a coding error.</p>"},{"location":"BackdoorAssembly/#demonstration","title":"Demonstration","text":"<p>The following Foundry test illustrates the vulnerability:</p> <ul> <li>A <code>VulnerableLottery</code> contract appears to have standard access controls via <code>onlyAdmin</code> modifier.</li> <li>The <code>_getAdmin()</code> function uses assembly to load the admin address from storage slot 2.</li> <li>The <code>selectWinner()</code> function uses assembly to directly write to storage slot 1 (the <code>winner</code> variable).</li> <li>Alice (non-admin) cannot call <code>selectWinner()</code> and is correctly rejected.</li> <li>The admin bypasses normal state variable assignment and directly manipulates storage via <code>sstore</code>.</li> <li>The <code>SecureLottery</code> contract demonstrates the proper implementation without assembly tricks.</li> </ul>"},{"location":"BackdoorAssembly/#storage-layout","title":"Storage Layout","text":"<pre><code>Slot 0: prize (uint256)\nSlot 1: winner (address)\nSlot 2: admin (address)\n</code></pre> <p>The backdoor exploits direct storage access to modify <code>winner</code> without triggering Solidity's type checks or event emissions.</p>"},{"location":"BackdoorAssembly/#mitigation","title":"Mitigation","text":""},{"location":"BackdoorAssembly/#code-review-best-practices","title":"Code Review Best Practices","text":"<ul> <li>Audit all assembly blocks: Treat inline assembly as high-risk code requiring extra scrutiny.</li> <li>Verify storage slot access: Ensure <code>sload</code>/<code>sstore</code> operations align with declared state variables.</li> <li>Check for hidden privilege escalation: Look for assembly in access control functions.</li> <li>Require justification: Assembly should only be used when necessary for gas optimization or specific EVM features.</li> </ul>"},{"location":"BackdoorAssembly/#secure-implementation-pattern","title":"Secure Implementation Pattern","text":"<p>Replace assembly-based storage manipulation with explicit state variable access:</p> <pre><code>contract SecureLottery {\n    address public immutable admin;\n    address public winner;\n\n    event WinnerSelected(address indexed winner, uint256 prize);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized: caller is not admin\");\n        _;\n    }\n\n    function selectWinner(address candidate) external onlyAdmin {\n        require(candidate != address(0), \"Invalid winner address\");\n        winner = candidate;  // Explicit assignment, no assembly\n        emit WinnerSelected(candidate, prize);\n    }\n}\n</code></pre> <p>Key improvements:</p> <ul> <li>Use <code>immutable</code> for admin to prevent post-deployment modification</li> <li>Explicit state variable assignment instead of <code>sstore</code></li> <li>Event emission for transparency and off-chain monitoring</li> <li>Clear error messages for access control failures</li> </ul>"},{"location":"BackdoorAssembly/#running-the-test","title":"Running the Test","text":"<pre><code>forge test --match-contract BackdoorAssemblyTest -vvv\n</code></pre> <p>The <code>-vvv</code> flag displays detailed logs showing storage slot manipulation and access control bypass.</p>"},{"location":"BackdoorAssembly/#expected-output","title":"Expected Output","text":"<pre><code>Ran 3 tests for test/BackdoorAssembly.t.sol:BackdoorAssemblyTest\n[PASS] test_SecureImplementation() (gas: 56371)\nLogs:\n  === Secure Contract Implementation ===\n  Initial winner: 0x0000000000000000000000000000000000000000\n  Prize pool: 1000\n\nAlice attempts to call selectWinner (will fail):\n\nAdmin legitimately sets Bob as winner:\n  Legitimate winner: 0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF\n  Secure operation completed: Transparent access control enforced\n\n\n[PASS] test_StorageLayoutExploit() (gas: 39660)\nLogs:\n  === Storage Layout Analysis ===\n  Slot 0 (prize): 1000\n  Slot 1 (winner): 0x0000000000000000000000000000000000000000\n  Slot 2 (admin): 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n\nSlot 1 after exploit: 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf\n\n[PASS] test_VulnerableBackdoorExploit() (gas: 56392)\nLogs:\n  === Vulnerable Contract Exploit ===\n  Initial winner: 0x0000000000000000000000000000000000000000\n  Prize pool: 1000\n\nAlice attempts to call selectWinner (will fail):\n\nAdmin exploits backdoor to set Bob as winner:\n  Manipulated winner: 0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF\n  Exploit completed: Admin bypassed controls via assembly\n\n\nSuite result: ok. 3 passed; 0 failed; 0 skipped; finished in 1.36ms (768.10\u00b5s CPU time)\n\nRan 1 test suite in 6.07ms (1.36ms CPU time): 3 tests passed, 0 failed, 0 skipped (3 total tests)\n</code></pre> <p>The logs confirm:</p> <ul> <li>Vulnerable contract: Admin successfully manipulates winner via assembly <code>sstore</code></li> <li>Storage analysis: Direct observation of storage slot modification</li> <li>Secure contract: Proper access control with event emission</li> </ul>"},{"location":"BackdoorAssembly/#real-world-impact","title":"Real-World Impact","text":"<p>Assembly backdoors have been exploited in multiple high-profile incidents:</p>"},{"location":"BackdoorAssembly/#common-backdoor-patterns","title":"Common Backdoor Patterns","text":"<ul> <li>Hidden mint functions: Assembly-based token creation bypassing supply caps</li> <li>Ownership manipulation: Direct storage writes to change contract owner</li> <li>Fee extraction: Assembly logic to redirect funds to attacker addresses</li> <li>Pause bypasses: Admin-only assembly paths that ignore pause mechanisms</li> </ul>"},{"location":"BackdoorAssembly/#audit-recommendations","title":"Audit Recommendations","text":"<ul> <li>Flag all assembly usage for manual review</li> <li>Verify storage layout matches state variable declarations</li> <li>Test access controls with both legitimate and malicious actors</li> <li>Compare bytecode against source to detect hidden assembly</li> <li>Require multi-sig approval for contracts containing assembly</li> </ul> <p>Trust assumption: Any contract with unexplained assembly should be considered high-risk until proven otherwise through comprehensive auditing.</p>"},{"location":"BackdoorAssemblyV2/","title":"Hidden Assembly Backdoor Vulnerability V2","text":""},{"location":"BackdoorAssemblyV2/#overview","title":"Overview","text":"<p>Inline assembly provides low-level EVM access, enabling direct storage manipulation via <code>sload</code> and <code>sstore</code>. Malicious actors exploit this to embed hidden backdoors that bypass Solidity's type safety and access controls.</p> <p>This demonstration shows a deceptive lottery contract that appears fair but contains a hidden admin privilege. When the admin calls <code>drawWinner()</code>, assembly code secretly overrides the random selection\u2014allowing the admin to always win without participating.</p>"},{"location":"BackdoorAssemblyV2/#vulnerability-mechanism","title":"Vulnerability Mechanism","text":""},{"location":"BackdoorAssemblyV2/#storage-layout","title":"Storage Layout","text":"<pre><code>Slot 0: participants[] (dynamic array pointer)\nSlot 1: winner (address)\nSlot 2: admin (address)\nSlot 3: prizePool (uint256)\n</code></pre>"},{"location":"BackdoorAssemblyV2/#backdoor-code","title":"Backdoor Code","text":"<pre><code>function drawWinner() external {\n    // Visible \"fair\" random selection\n    uint256 randomIndex = uint256(\n        keccak256(abi.encodePacked(block.timestamp, block.prevrandao, participants.length))\n    ) % participants.length;\n    address selectedWinner = participants[randomIndex];\n\n    // Hidden backdoor via assembly\n    assembly {\n        if eq(caller(), sload(2)) {       // If caller == admin (slot 2)\n            selectedWinner := caller()     // Override with admin address\n        }\n    }\n\n    winner = selectedWinner;\n}\n</code></pre>"},{"location":"BackdoorAssemblyV2/#attack-flow","title":"Attack Flow","text":"<ol> <li>Users join lottery, depositing 0.1 ETH each</li> <li>Admin calls <code>drawWinner()</code> \u2014 assembly backdoor triggers</li> <li><code>selectedWinner</code> silently replaced with admin's address</li> <li>Admin claims entire prize pool without participating</li> </ol>"},{"location":"BackdoorAssemblyV2/#demonstration","title":"Demonstration","text":"<p>The test suite includes five scenarios:</p> <ul> <li>test_VulnerableBackdoorExploit: Admin wins despite not participating</li> <li>test_VulnerableNormalDraw: Non-admin caller gets legitimate random result</li> <li>test_SecureLotteryV2FairDraw: Secure contract with commit-reveal randomness</li> <li>test_StorageLayoutAnalysis: Direct storage slot inspection</li> <li>test_FullExploitScenario: Complete rug pull \u2014 admin drains all funds</li> </ul>"},{"location":"BackdoorAssemblyV2/#mitigation","title":"Mitigation","text":""},{"location":"BackdoorAssemblyV2/#secure-implementation-commit-reveal","title":"Secure Implementation: Commit-Reveal","text":"<pre><code>function initiateDraw() external {\n    drawBlock = block.number + 1;  // Commit to future block\n}\n\nfunction finalizeWinner() external {\n    bytes32 blockHash = blockhash(drawBlock);  // Reveal using future hash\n    uint256 randomIndex = uint256(\n        keccak256(abi.encodePacked(blockHash, participants.length))\n    ) % participants.length;\n    winner = participants[randomIndex];\n}\n</code></pre>"},{"location":"BackdoorAssemblyV2/#best-practices","title":"Best Practices","text":"<ul> <li>Audit all assembly blocks \u2014 Treat as high-risk code</li> <li>Verify storage slot access \u2014 Ensure <code>sload</code>/<code>sstore</code> align with declarations</li> <li>Use immutable for privileges \u2014 Prevent post-deployment modification</li> <li>Emit events for critical operations \u2014 Enable off-chain monitoring</li> <li>Implement commit-reveal \u2014 Prevent manipulation of randomness</li> </ul>"},{"location":"BackdoorAssemblyV2/#running-the-test","title":"Running the Test","text":"<pre><code>forge test --match-contract BackdoorAssemblyV2Test -vvv\n</code></pre>"},{"location":"BackdoorAssemblyV2/#expected-output","title":"Expected Output","text":"<pre><code>Ran 5 tests for test/BackdoorAssemblyV2.t.sol:BackdoorAssemblyV2Test\n[PASS] test_FullExploitScenario() (gas: 180530)\nLogs:\n  === Full Exploit: Admin Drains Prize Pool ===\n\n  Prize pool: 0.3 ETH from Alice, Bob, Charlie\n  Admin contributed: 0 ETH\n\nAdmin profit: 0 ETH\n  RUG PULL COMPLETE: Admin drained all user funds\n\n[PASS] test_SecureLotteryV2FairDraw() (gas: 221618)\nLogs:\n  === Secure Lottery: Transparent Draw ===\n\n  Participants: Alice, Bob, Charlie\n  Prize pool: 0 ETH\n\nInitiating draw (commit phase)...\n  Draw block: 2\n\nFinalizing winner (reveal phase)...\n  Winner: 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf\n  Fair draw: Winner is verifiably random participant\n\n[PASS] test_StorageLayoutAnalysis() (gas: 156798)\nLogs:\n  === Storage Layout Analysis ===\n\n  Before drawWinner:\n    Slot 1 (winner): 0x0000000000000000000000000000000000000000\n    Slot 2 (admin): 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n\nAfter admin calls drawWinner:\n    Slot 1 (winner): 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n\n[PASS] test_VulnerableBackdoorExploit() (gas: 197648)\nLogs:\n  === Vulnerable Lottery: Hidden Backdoor ===\n\n  Participants: Alice, Bob, Charlie\n  Prize pool: 0 ETH\n\nAdmin calls drawWinner()...\n  Code appears to select random participant\n  But assembly backdoor overrides result\n\n  Winner: 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n  Admin: 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n\nEXPLOIT: Admin won without being a participant!\n\n[PASS] test_VulnerableNormalDraw() (gas: 157885)\nLogs:\n  === Vulnerable Lottery: Normal User Draw ===\n\n  Participants: Alice, Bob\n  Winner: 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf\n  Normal draw: Winner is a legitimate participant\n\nSuite result: ok. 5 passed; 0 failed; 0 skipped; finished in 1.01ms (825.11\u00b5s CPU time)\n</code></pre>"},{"location":"BackdoorAssemblyV2/#comparison","title":"Comparison","text":"Feature VulnerableLotteryV2 SecureLotteryV2 Randomness Current block (predictable) Future block hash Admin Privilege Hidden backdoor override None Auditability Assembly hides logic Pure Solidity Admin Declaration <code>address public</code> <code>address public immutable</code> Draw Process Single-step (manipulable) Two-step commit-reveal"},{"location":"BackdoorAssemblyV2/#real-world-impact","title":"Real-World Impact","text":"<p>Hidden assembly backdoors have enabled numerous rug pulls:</p> <ul> <li>Deceptive fairness: Contract appears legitimate during initial review</li> <li>Undetectable by users: Backdoor only visible in low-level code</li> <li>Complete fund drainage: Admin extracts all deposited assets</li> </ul> <p>Trust assumption: Any contract with unexplained assembly should be considered high-risk until verified through comprehensive auditing.</p>"}]}